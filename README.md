# Практическое изучение отказоустойчивости, часть 1. Обработка отказа СУБД при помощи физической потоковой репликации.


Посчитали уместным объеденить 2 прктических задания в одну работу, т.к. архитектура идентична.


Архитектура

3 ВМ ОС Centos7 с установленным Postgresql_12
1) Arbiter node (192.168.187.130)
2) Master node (192.168.187.128)
3) Slave node (192.168.187.129)

На ВМ Master и Slave настроена синхронная потоковая репликация с параметром (synchronous_commit=on).
Процедуры обработки отказа строятся на bash-скриптах, которые выполняются на ВМ.



Логика обработки отказов

На Master node запущен скрипт, опрашивающий Arbiter и Slave узлы с переодичностью в 1 минуту.

1.) Если связь с Arbiter и с Slave узлами потеряна - скрипт перезапускает сервер postgres.


На Slave node запущен скрипт, опрашивающий Arbiter и Master узлы с переодичностью в 1 минуту.

1.) Если связь с Arbiter и с Master узлами потеряна - скрипт перезапускает сервер postgres.

2.) Если связь с Master потеряна, то Slave опрашивает Arbiter и если тот подтвердит, что у него связь с Master отсутствует, то происходит promote Slave до Master узла.


На Ariter node запущен скрипт, опрашивающий Master и Slave узлы с переодичностью в 1 минуту.

1.) Если связь с Slave и с Master узлами потеряна - скрипт перезапускает сервер postgres.

2.) Если получен запрос от Slave о недоступности Master, Arbiter проверяет доступность с Master и при её отсутствие, отпрваляет Slave подтверждение отсутствия связи c Master.



Испытание

Было создано 3 скрипта: arbit.sh, master.sh, slave.sh - которые были размещены на соответствующих узлах. После запуска скриптов в случайные моменты времени, командой ifdown <int>, выключали в разной последовательности сетевые интерфейсы на устройствах и скрипты записывали соответствующие записи в лог файлы - slave.log, master.log, arbit.log.




# Практическое изучение отказоустойчивости, часть 2. Верификация системы обработки отказа СУБД.


В этой работе действующими лицами будут Slave и Master узлы. Скрипт total.sh запущен на Master узле. 


Логика работы скрипта.

В процессе работы скрипт создаёт 4 временных файла-счётчиков (err - количество неудачных вставок, suc - количество успешных вставок, slave.total - количество фактических строк на Slave узле в таблице после востановления связи, master.total - количество фактических строк на Master узле в таблице после востановления связи). Количество неудачных/удачных вставок скрипт определяет по переменной TIMEOUT равной 3 секундам, если ответ от сервера не приходит в течении 3 секунд, то вставка считается неудачной. Асинхронные запросы на вставку происходят примерно каждые 0.1 секунду. После выполнения всех ассинхронных запросов, скрипт выводит статистику состоящую из 4 временных файлов.

Каждое испытание проводилось с различным состоянием параметра synchronous_commit. Ниже приведены результаты. В случайные периоды времени связь между Master и Slave будет разорвана с помощью отключения сетевого интерфейса. После скрипта связь будет востановлена для того, чтобы репликация отработала.

Результаты

1.)synchronous_commit=off
Количество успешных запросов: 6000
Количество неудачных запросов: 0
Фактическое количество строк в Master: 6000
Фактическое количество строк в Slave: 4502

Итог. Данные не успели полностью реплецироваться на Slave узел, репликация происходит ассинхронно и нужно дополнительное время.


2.)synchronous_commit=local
Количество успешных запросов: 6000
Количество неудачных запросов: 0
Фактическое количество строк в Master: 6000
Фактическое количество строк в Slave: 6000

Итог. Все данные успешно реплицировались на Slave сервер, хотя репликация и ассинхронная, но нам не удалось поймать момент незавершенного процесса.


3.)synchronous_commit = remote_write
Количество успешных запросов: 3913
Количество неудачных запросов: 2087
Фактическое количество строк в Master: 6000
Фактическое количество строк в Slave: 6000

Итог. Хоть скрипт и не получил подтверждения вставки от Master в момент выполнения, однако данные были записаны и в последствии реплицировались на Slave.


4.)synchronous_commit = on
Количество успешных запросов: 2754
Количество неудачных запросов: 3246
Фактическое количество строк в Master: 2754
Фактическое количество строк в Slave: 2754

Итог. Картина выглядет логично. В тот момент, когда связь была потеряна с Slave, Master от него не смог получить подтверждение транзакции и соответственно не записал эти данные. В данном случае скрипт верно посчитал количество успешных запросов.



5.)synchronous_commit = remote_apply
Количество успешных запросов: 5103
Количество неудачных запросов: 897
Фактическое количество строк в Master: 5103
Фактическое количество строк в Slave: 5103

Итог. Ситуация идентична предыдущей. Мы так и не смогли увидеть разницу между 4 и 5 режимами работы.

# Практическое изучение отказоустойчивости, часть 1. Обработка отказа СУБД при помощи физической потоковой репликации

Мы посчитали уместным объединить два практических задания в одну работу, так как архитектура идентична.

## Архитектура

3 ВМ ОС Centos7 с установленным Postgresql_12:
1. Arbiter node (192.168.187.130)
2. Master node (192.168.187.128)
3. Slave node (192.168.187.129)

На ВМ Master и Slave настроена синхронная потоковая репликация с параметром `synchronous_commit=on`. Процедуры обработки отказа строятся на bash-скриптах, которые выполняются на ВМ.

## Логика обработки отказов

### Master node
Запущен скрипт, опрашивающий Arbiter и Slave узлы с периодичностью в 1 минуту.
1. Если связь с Arbiter и с Slave узлами потеряна, скрипт перезапускает сервер postgres.

### Slave node
Запущен скрипт, опрашивающий Arbiter и Master узлы с периодичностью в 1 минуту.
1. Если связь с Arbiter и с Master узлами потеряна, скрипт перезапускает сервер postgres.
2. Если связь с Master потеряна, то Slave опрашивает Arbiter, и если тот подтверждает, что у него связь с Master отсутствует, то происходит promote Slave до Master узла.

### Arbiter node
Запущен скрипт, опрашивающий Master и Slave узлы с периодичностью в 1 минуту.
1. Если связь с Slave и с Master узлами потеряна, скрипт перезапускает сервер postgres.
2. Если получен запрос от Slave о недоступности Master, Arbiter проверяет доступность Master и при ее отсутствии отправляет Slave подтверждение отсутствия связи с Master.

## Испытание

Было создано три скрипта: `arbit.sh`, `master.sh`, `slave.sh`, которые были размещены на соответствующих узлах. После запуска скриптов в случайные моменты времени командой `ifdown <int>` выключали в разной последовательности сетевые интерфейсы на устройствах. Скрипты записывали соответствующие записи в лог файлы: `slave.log`, `master.log`, `arbit.log`.

# Практическое изучение отказоустойчивости, часть 2. Верификация системы обработки отказа СУБД

В этой работе действующими лицами будут Slave и Master узлы. Скрипт `total.sh` запущен на Master узле.

## Логика работы скрипта

В процессе работы скрипт создает четыре временных файла-счетчика:
- `err` - количество неудачных вставок
- `suc` - количество успешных вставок
- `slave.total` - количество фактических строк на Slave узле в таблице после восстановления связи
- `master.total` - количество фактических строк на Master узле в таблице после восстановления связи

Количество неудачных/удачных вставок скрипт определяет по переменной TIMEOUT, равной 3 секундам. Если ответ от сервера не приходит в течение 3 секунд, то вставка считается неудачной. Асинхронные запросы на вставку происходят примерно каждые 0,1 секунды. После выполнения всех асинхронных запросов скрипт выводит статистику, состоящую из четырех временных файлов.

Каждое испытание проводилось с различным состоянием параметра `synchronous_commit`. Ниже приведены результаты. В случайные периоды времени связь между Master и Slave будет разорвана с помощью отключения сетевого интерфейса. После выполнения скрипта связь будет восстановлена, чтобы репликация завершилась.

## Результаты

### 1. `synchronous_commit=off`
- Количество успешных запросов: 6000
- Количество неудачных запросов: 0
- Фактическое количество строк на Master: 6000
- Фактическое количество строк на Slave: 4502

**Итог:** Данные не успели полностью реплицироваться на Slave узел, репликация происходит асинхронно и нужно дополнительное время.

### 2. `synchronous_commit=local`
- Количество успешных запросов: 6000
- Количество неудачных запросов: 0
- Фактическое количество строк на Master: 6000
- Фактическое количество строк на Slave: 6000

**Итог:** Все данные успешно реплицировались на Slave сервер. Хотя репликация и асинхронная, но нам не удалось поймать момент незавершенного процесса.

### 3. `synchronous_commit=remote_write`
- Количество успешных запросов: 3913
- Количество неудачных запросов: 2087
- Фактическое количество строк на Master: 6000
- Фактическое количество строк на Slave: 6000

**Итог:** Хоть скрипт и не получил подтверждения вставки от Master в момент выполнения, данные были записаны и впоследствии реплицировались на Slave.

### 4. `synchronous_commit=on`
- Количество успешных запросов: 2754
- Количество неудачных запросов: 3246
- Фактическое количество строк на Master: 2754
- Фактическое количество строк на Slave: 2754

**Итог:** Картина выглядит логично. В момент, когда связь была потеряна со Slave, Master не смог получить подтверждение транзакции и не записал эти данные. В данном случае скрипт верно посчитал количество успешных запросов.

### 5. `synchronous_commit=remote_apply`
- Количество успешных запросов: 5103
- Количество неудачных запросов: 897
- Фактическое количество строк на Master: 5103
- Фактическое количество строк на Slave: 5103

**Итог:** Ситуация идентична предыдущей. Мы не смогли увидеть разницу между 4 и 5 режимами работы.
